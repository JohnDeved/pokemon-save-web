#!/usr/bin/env tsx
/**
 * Demo script to show the memory analysis functionality without requiring mGBA
 */

import { BytePatternMatcher } from '../src/lib/memory-analysis/byte-pattern-matcher'
import type { MemoryRegion } from '../src/lib/memory-analysis/types'

console.log('\x1b[1m🔍 Pokemon Save Web - Memory Pattern Analysis Demo\x1b[0m\n')

// Known addresses for demonstration
const VANILLA_ADDRESS = 0x20244EC
const QUETZAL_ADDRESS = 0x20235B8

console.log('Known partyData addresses:')
console.log(`  Vanilla Emerald: 0x${VANILLA_ADDRESS.toString(16).toUpperCase()}`)
console.log(`  Quetzal ROM:     0x${QUETZAL_ADDRESS.toString(16).toUpperCase()}`)
console.log()

// Generate patterns for both addresses
console.log('\x1b[36m📋 Generated Byte Patterns:\x1b[0m')

const vanillaPatterns = BytePatternMatcher.createPartyDataPatterns(VANILLA_ADDRESS)
const quetzalPatterns = BytePatternMatcher.createPartyDataPatterns(QUETZAL_ADDRESS)

console.log(`\nVanilla Emerald patterns (${vanillaPatterns.length} total):`)
for (const pattern of vanillaPatterns.slice(0, 5)) {
  const bytes = Array.from(pattern.pattern).map(b => b.toString(16).padStart(2, '0')).join(' ')
  console.log(`  • ${pattern.name}: ${bytes}`)
  console.log(`    ${pattern.description}`)
}

console.log(`\nQuetzal patterns (${quetzalPatterns.length} total):`)
for (const pattern of quetzalPatterns.slice(0, 5)) {
  const bytes = Array.from(pattern.pattern).map(b => b.toString(16).padStart(2, '0')).join(' ')
  console.log(`  • ${pattern.name}: ${bytes}`)
  console.log(`    ${pattern.description}`)
}

// Simulate finding patterns in memory
console.log('\n\x1b[36m🎯 Pattern Detection Demo:\x1b[0m')

const matcher = new BytePatternMatcher()

// Create simulated memory regions with address references
const createSimulatedMemory = (targetAddress: number): MemoryRegion => {
  const data = new Uint8Array(0x1000)
  
  // Add direct address reference
  const addr = targetAddress >>> 0
  data[0x200] = addr & 0xFF
  data[0x201] = (addr >> 8) & 0xFF
  data[0x202] = (addr >> 16) & 0xFF
  data[0x203] = (addr >> 24) & 0xFF
  
  // Add Thumb LDR instruction pattern
  data[0x300] = 0x01  // LDR r0, [PC, #4]
  data[0x301] = 0x48
  data[0x304] = addr & 0xFF
  data[0x305] = (addr >> 8) & 0xFF
  data[0x306] = (addr >> 16) & 0xFF
  data[0x307] = (addr >> 24) & 0xFF
  
  return {
    address: 0x8000000, // ROM space
    size: data.length,
    data
  }
}

// Test vanilla emerald detection
console.log('\nTesting Vanilla Emerald detection:')
const vanillaMemory = createSimulatedMemory(VANILLA_ADDRESS)
const vanillaMatches = matcher.findAddressReferences([vanillaMemory], VANILLA_ADDRESS, 0x10)

console.log(`  Found ${vanillaMatches.length} potential references:`)
for (const match of vanillaMatches) {
  console.log(`    • 0x${match.address.toString(16)} (${(match.confidence * 100).toFixed(1)}% confidence)`)
  console.log(`      Referenced address: 0x${match.context?.referencedAddress?.toString(16)}`)
  console.log(`      Bytes: ${Array.from(match.matchedBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}`)
}

// Test quetzal detection
console.log('\nTesting Quetzal detection:')
const quetzalMemory = createSimulatedMemory(QUETZAL_ADDRESS)
const quetzalMatches = matcher.findAddressReferences([quetzalMemory], QUETZAL_ADDRESS, 0x10)

console.log(`  Found ${quetzalMatches.length} potential references:`)
for (const match of quetzalMatches) {
  console.log(`    • 0x${match.address.toString(16)} (${(match.confidence * 100).toFixed(1)}% confidence)`)
  console.log(`      Referenced address: 0x${match.context?.referencedAddress?.toString(16)}`)
  console.log(`      Bytes: ${Array.from(match.matchedBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}`)
}

// Demonstrate pattern specificity
console.log('\n\x1b[36m🧪 Pattern Specificity Test:\x1b[0m')
console.log('\nTesting cross-detection (should find no matches):')

// Try to find quetzal address in vanilla memory
const crossMatches = matcher.findAddressReferences([vanillaMemory], QUETZAL_ADDRESS, 0x10)
console.log(`  Searching for Quetzal address in Vanilla memory: ${crossMatches.length} matches`)

// Try to find vanilla address in quetzal memory  
const crossMatches2 = matcher.findAddressReferences([quetzalMemory], VANILLA_ADDRESS, 0x10)
console.log(`  Searching for Vanilla address in Quetzal memory: ${crossMatches2.length} matches`)

console.log('\n\x1b[32m✅ Demo completed successfully!\x1b[0m')
console.log('\nThis demonstrates that the byte pattern analysis can:')
console.log('  • Generate unique patterns for different ROM addresses')
console.log('  • Detect address references in simulated assembly code')
console.log('  • Distinguish between different ROM variants')
console.log('  • Provide confidence scores for matches')
console.log('\nTo use with real mGBA data:')
console.log('  1. Start mGBA Docker: npm run mgba -- start --game emerald')
console.log('  2. Run analysis: npm run memory-analyze analyze')
console.log('  3. Check results in /tmp/memory-analysis/')
console.log()