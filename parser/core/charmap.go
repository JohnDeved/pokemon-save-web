package core

import (
	"strings"
)

// PokemonCharMap maps byte values to Pokemon text characters
var PokemonCharMap = map[byte]string{
	0:   "　",
	1:   "あ",
	2:   "い",
	3:   "う",
	4:   "え",
	5:   "お",
	6:   "か",
	7:   "き",
	8:   "く",
	9:   "け",
	10:  "こ",
	11:  "さ",
	12:  "し",
	13:  "す",
	14:  "せ",
	15:  "そ",
	16:  "た",
	17:  "ち",
	18:  "つ",
	19:  "て",
	20:  "と",
	21:  "な",
	22:  "に",
	23:  "ぬ",
	24:  "ね",
	25:  "の",
	26:  "は",
	27:  "ひ",
	28:  "ふ",
	29:  "へ",
	30:  "ほ",
	31:  "ま",
	32:  "み",
	33:  "む",
	34:  "め",
	35:  "も",
	36:  "や",
	37:  "ゆ",
	38:  "よ",
	39:  "ら",
	40:  "り",
	41:  "る",
	42:  "れ",
	43:  "ろ",
	44:  "わ",
	45:  "を",
	46:  "ん",
	47:  "ぁ",
	48:  "ぃ",
	49:  "ぅ",
	50:  "ぇ",
	51:  "ぉ",
	52:  "ゃ",
	53:  "ゅ",
	54:  "ょ",
	55:  "が",
	56:  "ぎ",
	57:  "ぐ",
	58:  "げ",
	59:  "ご",
	60:  "ざ",
	61:  "じ",
	62:  "ず",
	63:  "ぜ",
	64:  "ぞ",
	65:  "だ",
	66:  "ぢ",
	67:  "づ",
	68:  "で",
	69:  "ど",
	70:  "ば",
	71:  "び",
	72:  "ぶ",
	73:  "べ",
	74:  "ぼ",
	75:  "ぱ",
	76:  "ぴ",
	77:  "ぷ",
	78:  "ぺ",
	79:  "ぽ",
	80:  "っ",
	81:  "ア",
	82:  "イ",
	83:  "ウ",
	84:  "エ",
	85:  "オ",
	86:  "カ",
	87:  "キ",
	88:  "ク",
	89:  "ケ",
	90:  "コ",
	91:  "サ",
	92:  "シ",
	93:  "ス",
	94:  "セ",
	95:  "ソ",
	96:  "タ",
	97:  "チ",
	98:  "ツ",
	99:  "テ",
	100: "ト",
	101: "ナ",
	102: "ニ",
	103: "ヌ",
	104: "ネ",
	105: "ノ",
	106: "ハ",
	107: "ヒ",
	108: "フ",
	109: "ヘ",
	110: "ホ",
	111: "マ",
	112: "ミ",
	113: "ム",
	114: "メ",
	115: "モ",
	116: "ヤ",
	117: "ユ",
	118: "ヨ",
	119: "ラ",
	120: "リ",
	121: "ル",
	122: "レ",
	123: "ロ",
	124: "ワ",
	125: "ヲ",
	126: "ン",
	127: "ァ",
	128: "ィ",
	129: "ゥ",
	130: "ェ",
	131: "ォ",
	132: "ャ",
	133: "ュ",
	134: "ョ",
	135: "ガ",
	136: "ギ",
	137: "グ",
	138: "ゲ",
	139: "ゴ",
	140: "ザ",
	141: "ジ",
	142: "ズ",
	143: "ゼ",
	144: "ゾ",
	145: "ダ",
	146: "ヂ",
	147: "ヅ",
	148: "デ",
	149: "ド",
	150: "バ",
	151: "ビ",
	152: "ブ",
	153: "ベ",
	154: "ボ",
	155: "パ",
	156: "ピ",
	157: "プ",
	158: "ペ",
	159: "ポ",
	160: "ッ",
	161: "0",
	162: "1",
	163: "2",
	164: "3",
	165: "4",
	166: "5",
	167: "6",
	168: "7",
	169: "8",
	170: "9",
	171: "！",
	172: "？",
	173: "。",
	174: "ー",
	175: "·",
	176: "⋯",
	177: "\u201c",
	178: "\u201d", 
	179: "\u2019",
	180: "\u2018",
	181: "♂",
	182: "♀",
	183: "¥",
	184: ",",
	185: "×",
	186: "/",
	187: "A",
	188: "B",
	189: "C",
	190: "D",
	191: "E",
	192: "F",
	193: "G",
	194: "H",
	195: "I",
	196: "J",
	197: "K",
	198: "L",
	199: "M",
	200: "N",
	201: "O",
	202: "P",
	203: "Q",
	204: "R",
	205: "S",
	206: "T",
	207: "U",
	208: "V",
	209: "W",
	210: "X",
	211: "Y",
	212: "Z",
	213: "a",
	214: "b",
	215: "c",
	216: "d",
	217: "e",
	218: "f",
	219: "g",
	220: "h",
	221: "i",
	222: "j",
	223: "k",
	224: "l",
	225: "m",
	226: "n",
	227: "o",
	228: "p",
	229: "q",
	230: "r",
	231: "s",
	232: "t",
	233: "u",
	234: "v",
	235: "w",
	236: "x",
	237: "y",
	238: "z",
	239: "▶",
	240: ":",
	241: "Ä",
	242: "Ö",
	243: "Ü",
	244: "ä",
	245: "ö",
	246: "ü",
	250: "\\l",
	251: "\\p",
	254: "\\n",
	255: " ",
}

// DecodePokemonText decodes Pokemon character-encoded bytes to string
func DecodePokemonText(data []byte) string {
	var result []string
	
	for _, b := range data {
		if b == 0xFF {
			// End of string marker
			break
		}
		
		if char, exists := PokemonCharMap[b]; exists {
			result = append(result, char)
		}
	}
	
	return strings.TrimSpace(strings.Join(result, ""))
}

// EncodePokemonText encodes a string to Pokemon character bytes
func EncodePokemonText(text string, maxLength int) []byte {
	// Create reverse map for encoding
	reverseCharMap := make(map[string]byte)
	for b, char := range PokemonCharMap {
		reverseCharMap[char] = b
	}
	
	result := make([]byte, maxLength)
	textRunes := []rune(text)
	
	i := 0
	for _, r := range textRunes {
		if i >= maxLength {
			break
		}
		
		char := string(r)
		if b, exists := reverseCharMap[char]; exists {
			result[i] = b
		} else {
			// Use space for unknown characters
			result[i] = 255
		}
		i++
	}
	
	// Fill remaining with end-of-string markers
	for i < maxLength {
		result[i] = 0xFF
		i++
	}
	
	return result
}