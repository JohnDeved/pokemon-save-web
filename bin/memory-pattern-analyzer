#!/usr/bin/env tsx
/**
 * CLI tool for analyzing memory patterns to find partyData addresses
 */

import { MgbaWebSocketClient } from '../src/lib/mgba/websocket-client'
import { MemoryAnalyzer } from '../src/lib/memory-analysis/memory-analyzer'
import { mkdirSync } from 'node:fs'
import { resolve } from 'node:path'

// Known addresses for pattern analysis
const KNOWN_ADDRESSES = {
  vanilla: 0x20244ec,  // Vanilla Emerald
  quetzal: 0x20235b8   // 1uetzal (Quetzal)
}

async function printHelp() {
  console.log('\n\x1b[1mPok√©mon Save Web: Memory Pattern Analyzer\x1b[0m\n')
  console.log('Usage: tsx bin/memory-pattern-analyzer <command> [options]\n')
  console.log('Commands:')
  console.log('  \x1b[36manalyze\x1b[0m          Perform dynamic analysis to find partyData addresses using IDA-style patterns')
  console.log('  \x1b[36mquick [address]\x1b[0m  Quick analysis to find party data addresses (optionally around specific address)')
  console.log('  \x1b[36mdump\x1b[0m             Dump EWRAM and IWRAM to disk for manual analysis')
  console.log('  \x1b[36mhelp\x1b[0m             Show this help message')
  console.log('\nOptions:')
  console.log('  --ws-url <url>       WebSocket URL (default: ws://localhost:7102/ws)')
  console.log('  --output-dir <dir>   Output directory (default: /tmp/memory-analysis)')
  console.log('\nExamples:')
  console.log('  tsx bin/memory-pattern-analyzer analyze')
  console.log('  tsx bin/memory-pattern-analyzer quick')
  console.log('  tsx bin/memory-pattern-analyzer quick 20244ec')
  console.log('  tsx bin/memory-pattern-analyzer dump --output-dir ./analysis')
  console.log('\nNew Dynamic Approach:')
  console.log('  This tool now uses IDA-style byte patterns to dynamically detect party data')
  console.log('  addresses by finding assembly instructions that reference them, rather than')
  console.log('  relying on hardcoded addresses. This enables support for ROM updates and new')
  console.log('  Pokemon ROM hacks automatically.')
  console.log('')
}

async function connectToMgba(wsUrl) {
  console.log(`Connecting to mGBA at ${wsUrl}...`)
  
  const client = new MgbaWebSocketClient(wsUrl)
  
  try {
    await client.connect()
    console.log('‚úÖ Connected to mGBA WebSocket server')
    
    // Test connection by getting game title
    const gameTitle = await client.getGameTitle()
    console.log(`üéÆ Game: ${gameTitle}`)
    
    return client
  } catch (error) {
    console.error('‚ùå Failed to connect to mGBA:', error)
    console.log('\nüí° Make sure mGBA Docker container is running:')
    console.log('   npm run mgba -- start --game emerald')
    console.log('   # or')
    console.log('   npm run mgba -- start --game quetzal')
    process.exit(1)
  }
}

async function runFullAnalysis(client, outputDir) {
  console.log('\nüîç Starting dynamic memory pattern analysis...')
  console.log('   Using IDA-style patterns to find assembly instructions that reference party data')
  
  const analyzer = new MemoryAnalyzer(client)
  
  try {
    const result = await analyzer.analyzePartyDataPatterns(KNOWN_ADDRESSES, outputDir)
    
    console.log('\nüìä Analysis Results:')
    console.log(`   ROM: ${result.romName}`)
    console.log(`   Detected Address: ${result.detectedPartyDataAddress ? '0x' + result.detectedPartyDataAddress.toString(16) : 'Not detected'}`)
    console.log(`   Confidence: ${(result.confidence * 100).toFixed(1)}%`)
    console.log(`   Pattern Matches: ${result.patterns.length}`)
    console.log(`   Suggested IDA Patterns: ${result.suggestedPatterns.length}`)
    
    if (result.patterns.length > 0) {
      console.log('\nüéØ Top Pattern Matches:')
      for (const match of result.patterns.slice(0, 5)) {
        console.log(`   ‚Ä¢ ${match.pattern.name} at 0x${match.address.toString(16)} (${(match.confidence * 100).toFixed(1)}% confidence)`)
        if (match.context?.referencedAddress) {
          console.log(`     References: 0x${match.context.referencedAddress.toString(16)}`)
        }
      }
    }
    
    if (result.suggestedPatterns.length > 0) {
      console.log('\nüîß Generated IDA-Style Patterns:')
      for (const pattern of result.suggestedPatterns.slice(0, 3)) {
        const patternStr = Array.from(pattern.pattern).map(b => b.toString(16).padStart(2, '0')).join(' ')
        const maskStr = pattern.mask ? 
          ` (mask: ${Array.from(pattern.mask).map(b => b.toString(16).padStart(2, '0')).join(' ')})` : ''
        console.log(`   ‚Ä¢ ${pattern.name}: ${patternStr}${maskStr}`)
        console.log(`     ${pattern.description}`)
      }
    }
    
    console.log(`\nüíæ Analysis reports saved to: ${outputDir}`)
    console.log('   ‚Ä¢ analysis_report.json (detailed)')
    console.log('   ‚Ä¢ analysis_report.txt (human-readable)')
    console.log('   ‚Ä¢ ewram_dump.bin (EWRAM memory dump)')
    console.log('   ‚Ä¢ iwram_dump.bin (IWRAM memory dump)')
    
  } catch (error) {
    console.error('‚ùå Analysis failed:', error)
    process.exit(1)
  }
}

async function runQuickAnalysis(client, addressStr, outputDir) {
  let address = null
  
  if (addressStr) {
    address = parseInt(addressStr, 16)
    if (isNaN(address)) {
      console.error('‚ùå Invalid address format. Use hex format (e.g., 20244ec)')
      process.exit(1)
    }
    console.log(`\nüîç Quick analysis around address 0x${address.toString(16)}...`)
  } else {
    console.log('\nüîç Quick analysis for dynamic party data address detection...')
  }
  
  const analyzer = new MemoryAnalyzer(client)
  
  try {
    const matches = await analyzer.quickAddressAnalysis(address, outputDir)
    
    console.log(`\nüìä Found ${matches.length} potential references:`)
    
    for (const match of matches.slice(0, 10)) {
      const patternBytes = Array.from(match.matchedBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')
      console.log(`   ‚Ä¢ 0x${match.address.toString(16)}: ${patternBytes} (${(match.confidence * 100).toFixed(1)}%)`)
      console.log(`     Pattern: ${match.pattern.name}`)
      if (match.context?.referencedAddress) {
        console.log(`     -> References: 0x${match.context.referencedAddress.toString(16)}`)
      }
    }
    
    const outputFile = address ? 
      `quick_analysis_${address.toString(16)}.json` :
      'quick_analysis_auto.json'
    console.log(`\nüíæ Quick analysis saved to: ${outputDir}/${outputFile}`)
    
  } catch (error) {
    console.error('‚ùå Quick analysis failed:', error)
    process.exit(1)
  }
}

async function runMemoryDump(client, outputDir) {
  console.log('\nüíæ Dumping memory regions to disk...')
  
  const analyzer = new MemoryAnalyzer(client)
  
  try {
    // Access the dumper through the analyzer
    const dumper = analyzer.getMemoryDumper()
    
    console.log('   Dumping EWRAM...')
    await dumper.dumpEWRAM(`${outputDir}/ewram_dump.bin`)
    
    console.log('   Dumping IWRAM...')
    await dumper.dumpIWRAM(`${outputDir}/iwram_dump.bin`)
    
    console.log(`\n‚úÖ Memory dumps saved to: ${outputDir}`)
    console.log('   ‚Ä¢ ewram_dump.bin (256KB EWRAM)')
    console.log('   ‚Ä¢ iwram_dump.bin (32KB IWRAM)')
    console.log('\nüí° You can now analyze these dumps with hex editors or other tools')
    
  } catch (error) {
    console.error('‚ùå Memory dump failed:', error)
    process.exit(1)
  }
}

async function main() {
  const args = process.argv.slice(2)
  
  if (args.length === 0 || args.includes('help') || args.includes('--help')) {
    await printHelp()
    process.exit(0)
  }
  
  const command = args[0]
  let wsUrl = 'ws://localhost:7102/ws'
  let outputDir = '/tmp/memory-analysis'
  
  // Parse options
  for (let i = 1; i < args.length; i++) {
    if (args[i] === '--ws-url' && args[i + 1]) {
      wsUrl = args[i + 1]
      i++
    } else if (args[i] === '--output-dir' && args[i + 1]) {
      outputDir = resolve(args[i + 1])
      i++
    }
  }
  
  // Ensure output directory exists
  mkdirSync(outputDir, { recursive: true })
  console.log(`üìÅ Output directory: ${outputDir}`)
  
  // Connect to mGBA
  const client = await connectToMgba(wsUrl)
  
  try {
    switch (command) {
      case 'analyze':
        await runFullAnalysis(client, outputDir)
        break
        
      case 'quick':
        // Address argument is now optional
        const targetAddress = args[1]
        await runQuickAnalysis(client, targetAddress, outputDir)
        break
        
      case 'dump':
        await runMemoryDump(client, outputDir)
        break
        
      default:
        console.error(`‚ùå Unknown command: ${command}`)
        await printHelp()
        process.exit(1)
    }
  } finally {
    client.disconnect()
  }
  
  console.log('\n‚úÖ Analysis complete!')
}

// Run CLI
main().catch((error) => {
  console.error('üí• Unexpected error:', error)
  process.exit(1)
})